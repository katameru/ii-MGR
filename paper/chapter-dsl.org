
* Dive into DSLs

* Classification
One way to classify DSLs is to look at their relationship with the language used to implement them. The basic split is between external and internal (or embedded) DSLs. An external DSL is one that has syntax wholly independent from the implementing language and needs a custom parser. An embedded DSL is essentialy a library of the implementing (or host) language which provides abstractions over the domain-specific knowledge.

** External DSL

An external DSL gives us the most flexibility of syntax. Since we are not constrained by the rules of the host language, the source code can be have a form that is the best way of modeling a solution of a domain problem: a set of symbolic equations, files in a specific hierarchy on disk or a list of turtle movement instructions. Custom syntax will usually mean a significant rise in complexity and drop in usability.

*** Issues: parsing

One of the main issues in external DSLs is that we need to parse the source files into an internal representation. Scala has several options for parsing libraries and parser generators which make simplify this step significantly. However, languages with complex grammars will still result in complex parsers, and any input that isn't text-based (eg. image, binary file) will need to be parsed using custom-written code.

*** Issues: tooling

A usability issue that arises when we use an external DSL is that various development tools cannot be used to aid the programmer. Unless we implement it ourselves, we have no syntax highlighting or autocompletion in an editor. We also lose the ability to easily debug code, since the executing program is either an interpreter written in the host language, or a compiled executable. In such cases, we must track extra information about the program source, so we can correctly trace the execution.

** Internal DSL

An internal DSL leverages the the host language to build programs. This solution can be severly limiting in terms of language syntax because the DSL grammar needs to conform to the grammar of the host language. However, some languages (Scala included) have ways to bend their syntax into multiple forms.

A large benefit of using internal DSLs is that we don't need to worry about parsing. We can also use the type system of the host language to embed a type system in the DSL.

A nice property of internal DSLs is that they can interoperate with other programs writeen in the host language. For example, wa can have an internal DSL in Scala that allows us to run computations on large remote datasets. We can then use functions from a third-party Scala library to run complex computations on that data.

Internal DSLs can be further split into two groups: shallow embeddings and deep embeddings.

*** Shallow embeddings

A shallow embedding structures and names constructs in the host language in such a way that makes a program written in the DSL map directly into a program in the host language with the same semantics.

`
val result = compute(2)
result should be(4)
`
 - fragment of a ScalaTest test. The line `result should be(4)` checks if the result of the computation is an expected value. If not, it fails the test and generates a descriptive error message.

In this situation every stage of a programs lifetime, from parsing to execution is handled by the host language. This gives us all the benefits that we would have when writing a program in the host language: development tools, an optimizing compiler/interpreter, externally verified code generation.

*** Deep embeddings

A deep embedding separates the representation of the DSL from its execution. We use the host language to create the structure of a program, which will be later compiled or interpreted by another part of the DSL.

`
val rdd = 
  sparkContext.fromFile("data.csv").filter(...).map(...)
println(rdd.sum)
`
 - an abbreviated spark program. The variable rdd holds metadata that describe the loading and transforming of some data. This will be compiled to an execution plan and executed on multiple computers, completely transparently to the user.

While this form of DSL doesn't make any allowances for handy syntax, it can be much more expressive and powerful than a shallow embedding. A shallow embedding needs to map cleanly into the host language. A deep embedding doesn't have that restriction, which opens up the possibility of using more powerful abstractions.

Furthermore, while a deep DSL requires the implementation of a custom compiler/interpreter, it gives us the option to embed domain knowledge into the execution of a program. With an interpreter, we gain the option to use information gathered at runtime to make optimizations that would not be possible with a naive interpreter. If we compile a program to native code, we can generate code that uses assumptions that would not be available to a generic compiler. We can also generate code for non-standard targets, such as GPUs or FPGAs.

* Outro

*** Decisions

An external DSL allows for the most flexibility of syntax. It is also the only option if we want to have a once deployed interpreter/compiler. Sice internal DSLs are programs written in the host language, any change to a program means a redeployment.

Deep embeddings are a good choice if the syntax is not a big concern, and we want to skip writing parsers and use exisitng development tools to write programs in our DSL.

Shallow embeddings are a good choice if we can cleanly map our domain-specific concepts onto the host language and don't need to write custom compiling/interpreting code.
