\appendix
\chapter{Code Listings}
\begin{lstlisting}[caption=Existential inference, label=code:existentials, escapechar=|, float, floatplacement=H]
trait InternalBound

class InternalImpl extends InternalBound

trait Container {
  type Internal <: InternalBound
}

class ContainerImpl extends Container {
  type Internal = InternalImpl
}

object Test {
  type ContainerWithInternal = (T, T#Internal) forSome { type T <: Container; }
  type CS = (A, B) forSome { type A <: Container; type B <: A#Internal }

  def construct[T <: Container](i: T, e: T#Internal): ContainerWithInternal = (i, e)

  //Type error
  //def constructCS1[A <: Container](a: A, b: A#Internal): CS = (a, b) |\label{line:why}|
  def constructCS2[A <: Container](a: A, b: A#Internal): CS = (a, b): (A, A#Internal)

  def main(args: Array[String]): Unit = {

    val container = new ContainerImpl
    val internal = new container.Internal()
    val internalWithCast: container.Internal = new container.Internal()

    //Type errors
    //val res1: ContainerWithInternal = (container, internal)
    //val res2: ContainerWithInternal = construct(container, internal)
    val res3: ContainerWithInternal = construct(container, (internal: container.Internal))
    val res4: ContainerWithInternal = construct[ContainerImpl](container, internal)

    val res5: ContainerWithInternal = (container, internalWithCast)
    val res6: ContainerWithInternal = construct(container, internalWithCast)
    val res7: ContainerWithInternal = construct[ContainerImpl](container, internalWithCast)
  }
}
\end{lstlisting}

\begin{lstlisting}[caption=ColumnAggregateDescription, label=code:cad]
case class ColumnAggregateDescription[ColumnType](
    sourceColumnDescription: SourceColumnDescription[ColumnType],
    aggregateBuilder: AggregateBuilder[ColumnType],
    outputName: String) {
  def fresh: ColumnAggregate[ColumnType] = new ColumnAggregate(sourceColumnDescription, aggregateBuilder.fresh, outputName)
}

class ColumnAggregate[-ColumnType](
    sourceColumnDescription: SourceColumnDescription[ColumnType],
    aggregate: Aggregate[ColumnType],
    outputName: String) {
  def add(entry: Entry) = sourceColumnDescription.parseEntry(entry).foreach { aggregate.add(_) }
  def output: Seq[(String, String)] = aggregate.getOutput
}
\end{lstlisting}

\begin{lstlisting}[caption=SourceColumnDescription, label=code:scd, float]
case class SourceColumnDescription[+Column](columnName: String, columnParser: ColumnParser[Column]) {
  def parseEntry(entry: Entry): Option[Column] = {
    entry.get(columnName) flatMap columnParser.parse orElse columnParser.default
  }
}

trait ColumnParser[+A] {
  def name: String
  def parse(column: String): Option[A]
  def default: Option[A] = None
}
\end{lstlisting}

\begin{lstlisting}[caption=Aggregate, label=code:agg, float]
trait AggregateBuilder[-Elem] {
  type Aggr <: Aggregate[Elem]
  def fresh: Aggr
}

trait Aggregate[-Elem] {
  def add(e: Elem): this.type
  def getOutput: Seq[(String, String)]
}
\end{lstlisting}

\begin{lstlisting}[caption=GroupedDescription, label=code:grouped, float]
case class GroupedDescription(
	grouping: Seq[SourceColumnDescription[_]],
	descriptionsUnderGrouping: SeqColumnAggregateDescription[_]])
\end{lstlisting}

\begin{lstlisting}[caption=shallow package object, label=code:shallow, float]
package object shallow {
  //Parsers
  def int = IntParser
  def float = FloatParser
  def string = StringParser
  def nothing = EmptyParser

  //Parser default
  implicit class DefaultParser[A](parser: ColumnParser[A]) {
    def or(defaultValue: A): ColumnParser[A] = { new WithDefault(parser, defaultValue) }
  }

  //Aggregators
  def count[A] = new CounterBuilder[A]
  def count[A](p: A => Boolean) = new PredicateCounterBuilder[A](p)
  def mean = new MeanBuilder

  //Describe source column
  implicit class ColumnNameWrapper(columnName: String) {
    def as[A](columnParser: ColumnParser[A]): SourceColumnDescription[A] = SourceColumnDescription(columnName, columnParser)
  }

  //Describe aggregation
  implicit class SourceDescriptionWrapper[A](description: SourceColumnDescription[A]) {
    class IncompleteDescription(aggregateBuilder: AggregateBuilder[A]) {
      def into(outputName: String) = ColumnAggregateDescription(description, aggregateBuilder, outputName)
    }

    def summarise(aggregateBuilder: AggregateBuilder[A]) = new IncompleteDescription(aggregateBuilder)
  }
}
\end{lstlisting}

\begin{lstlisting}[caption=StatsConfiguration, label=code:config, float]
trait StatsConfiguration {
  class StubbedGroupedDescriptions(descriptions: Seq[ColumnAggregateDescription[_]]) {
    private val groupingBuffer: ArrayBuffer[SourceColumnDescription[String]] = ArrayBuffer()
    private[StatsConfiguration] def finishStub() = GroupedDescription(groupingBuffer.toSeq, descriptions)

    def groupBy(groupings: SourceColumnDescription[String]*): this.type = {
      groupingBuffer ++= groupings
      this
    }
  }

  private val groupedDescriptions: ArrayBuffer[StubbedGroupedDescriptions] = ArrayBuffer()
  protected def select(descriptions: ColumnAggregateDescription[_]*): StubbedGroupedDescriptions = {
    val stubbedDescription = new StubbedGroupedDescriptions(descriptions)
    groupedDescriptions += stubbedDescription
    stubbedDescription
  }

  def configure: Seq[GroupedDescription] = groupedDescriptions.map(_.finishStub())
}
\end{lstlisting}